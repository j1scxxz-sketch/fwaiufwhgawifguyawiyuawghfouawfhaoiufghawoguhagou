local Services = {
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    Workspace = game:GetService("Workspace"),
    UIS = game:GetService("UserInputService"),
    TweenService = game:GetService("TweenService"),
    Debris = game:GetService("Debris"),
}

local lp = Services.Players.LocalPlayer
local cam = Services.Workspace.CurrentCamera

local Cfg = {
    hitmarker = {
        enabled = true, 
        mode = "2D",
        color = Color3.fromRGB(255, 255, 255),
        size = 12, 
        thickness = 2, 
        duration = 0.3, 
        gap = 4, 
        outline = true, 
        outline_color = Color3.fromRGB(0, 0, 0), 
        outline_thickness = 1
    },
    hitClone = {
        Enabled = true, 
        Material = "Neon",
        Color = Color3.fromRGB(255, 255, 255),
        Lifetime = 2
    },
    tracer = { 
        Enabled = true, 
        Color = Color3.fromRGB(255, 255, 255), 
        Size = 0.1, 
        Duration = 1, 
        Style = "line",
        Material = "Neon"
    },
    monitoring = {
        last_damage = {},
        last_hit_time = 0,
        hit_cooldown = 0.1,
        ShotgunWeapons = { 
            ["[Double-Barrel SG]"] = true, 
            ["[DoubleBarrel]"] = true, 
            ["[TacticalShotgun]"] = true, 
            ["[Shotgun]"] = true 
        }
    }
}

local State = {
    Active3DHitmarkers = {},
    BulletTracers = {}
}

local function isBodyPart(name)
    local bodyParts = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg", "UpperTorso", "LowerTorso", "LeftUpperArm", "LeftLowerArm", "LeftHand", "RightUpperArm", "RightLowerArm", "RightHand", "LeftUpperLeg", "LeftLowerLeg", "LeftFoot", "RightUpperLeg", "RightLowerLeg", "RightFoot"}
    for _, v in pairs(bodyParts) do if v == name then return true end end
    return false
end

local function GetGunOrigin()
    local char = lp.Character
    if not char then return nil end
    local tool = char:FindFirstChildOfClass("Tool")
    if tool then
        local muzzle = tool:FindFirstChild("Muzzle") or tool:FindFirstChild("Handle")
        if muzzle then return muzzle.Position end
    end
    return char:FindFirstChild("Head") and char.Head.Position
end

local function IsHoldingShotgun()
    local char = lp.Character
    if not char then return false end
    local tool = char:FindFirstChildOfClass("Tool")
    return tool and Cfg.monitoring.ShotgunWeapons[tool.Name] or false
end

local function CreateBulletTracer(sPos, ePos, isShotgun)
    if not Cfg.tracer.Enabled then return end
    local style = Cfg.tracer.Style or "line"
    
    local function createSingleBeam(start, finish)
        if style == "line" then
            local beam = Instance.new("Part")
            beam.Anchored = true
            beam.CanCollide = false
            beam.Material = Enum.Material[Cfg.tracer.Material] or Enum.Material.Neon
            beam.Color = Cfg.tracer.Color
            beam.Size = Vector3.new(Cfg.tracer.Size, Cfg.tracer.Size, (start - finish).Magnitude)
            beam.CFrame = CFrame.new(start, finish) * CFrame.new(0, 0, -beam.Size.Z / 2)
            beam.Parent = workspace
            beam.Transparency = 0.3
            Services.TweenService:Create(beam, TweenInfo.new(Cfg.tracer.Duration), {Transparency = 1}):Play()
            Services.Debris:AddItem(beam, Cfg.tracer.Duration)
            
        elseif style == "beam" then
            local part = Instance.new("Part")
            part.Anchored, part.CanCollide, part.Transparency = true, false, 1
            part.Size = Vector3.new(0.1, 0.1, 0.1)
            part.CFrame = CFrame.new(start)
            local att0 = Instance.new("Attachment", part)
            part.Parent = workspace
            
            local part2 = Instance.new("Part")
            part2.Anchored, part2.CanCollide, part2.Transparency = true, false, 1
            part2.Size = Vector3.new(0.1, 0.1, 0.1)
            part2.CFrame = CFrame.new(finish)
            local att1 = Instance.new("Attachment", part2)
            part2.Parent = workspace
            
            local beam = Instance.new("Beam", part)
            beam.Attachment0, beam.Attachment1 = att0, att1
            beam.Color = ColorSequence.new(Cfg.tracer.Color)
            beam.Width0, beam.Width1 = Cfg.tracer.Size * 10, Cfg.tracer.Size * 10
            beam.FaceCamera, beam.Transparency = true, NumberSequence.new(0.3)
            
            Services.TweenService:Create(beam, TweenInfo.new(Cfg.tracer.Duration), {Transparency = NumberSequence.new(1)}):Play()
            Services.Debris:AddItem(part, Cfg.tracer.Duration)
            Services.Debris:AddItem(part2, Cfg.tracer.Duration)
            
        elseif style == "lightning" then
            local segments, offset, prevPos = 8, 2, start
            for i = 1, segments do
                local nextPos = start:Lerp(finish, i / segments) + Vector3.new(math.random(-offset, offset), math.random(-offset, offset), math.random(-offset, offset))
                local beam = Instance.new("Part", workspace)
                beam.Anchored, beam.CanCollide, beam.Material, beam.Color = true, false, Enum.Material[Cfg.tracer.Material] or Enum.Material.Neon, Cfg.tracer.Color
                beam.Size = Vector3.new(Cfg.tracer.Size * 0.5, Cfg.tracer.Size * 0.5, (prevPos - nextPos).Magnitude)
                beam.CFrame = CFrame.new(prevPos, nextPos) * CFrame.new(0, 0, -beam.Size.Z / 2)
                beam.Transparency = 0.2
                Services.TweenService:Create(beam, TweenInfo.new(Cfg.tracer.Duration), {Transparency = 1}):Play()
                Services.Debris:AddItem(beam, Cfg.tracer.Duration)
                prevPos = nextPos
            end
            
        elseif style == "fade line" then
            local segments = 10
            for i = 1, segments do
                local t = i / segments
                local segStart, segEnd = start:Lerp(finish, (i-1) / segments), start:Lerp(finish, t)
                local beam = Instance.new("Part", workspace)
                beam.Anchored, beam.CanCollide, beam.Material, beam.Color = true, false, Enum.Material[Cfg.tracer.Material] or Enum.Material.Neon, Cfg.tracer.Color
                beam.Size = Vector3.new(Cfg.tracer.Size, Cfg.tracer.Size, (segStart - segEnd).Magnitude)
                beam.CFrame = CFrame.new(segStart, segEnd) * CFrame.new(0, 0, -beam.Size.Z / 2)
                beam.Transparency = 0.2 + (t * 0.5)
                Services.TweenService:Create(beam, TweenInfo.new(Cfg.tracer.Duration), {Transparency = 1}):Play()
                Services.Debris:AddItem(beam, Cfg.tracer.Duration)
            end
            
        elseif style == "gradient beam" then
            local part = Instance.new("Part")
            part.Anchored, part.CanCollide, part.Transparency = true, false, 1
            part.Size = Vector3.new(0.1, 0.1, 0.1)
            part.CFrame = CFrame.new(start)
            local att0 = Instance.new("Attachment", part)
            part.Parent = workspace
            
            local part2 = Instance.new("Part")
            part2.Anchored, part2.CanCollide, part2.Transparency = true, false, 1
            part2.Size = Vector3.new(0.1, 0.1, 0.1)
            part2.CFrame = CFrame.new(finish)
            local att1 = Instance.new("Attachment", part2)
            part2.Parent = workspace
            
            local beam = Instance.new("Beam", part)
            beam.Attachment0, beam.Attachment1 = att0, att1
            beam.Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Cfg.tracer.Color),
                ColorSequenceKeypoint.new(0.5, Color3.new(1, 1, 1)),
                ColorSequenceKeypoint.new(1, Cfg.tracer.Color)
            })
            beam.Width0, beam.Width1 = Cfg.tracer.Size * 12, Cfg.tracer.Size * 5
            beam.FaceCamera, beam.Transparency = true, NumberSequence.new(0.2)
            
            Services.TweenService:Create(beam, TweenInfo.new(Cfg.tracer.Duration), {Transparency = NumberSequence.new(1)}):Play()
            Services.Debris:AddItem(part, Cfg.tracer.Duration)
            Services.Debris:AddItem(part2, Cfg.tracer.Duration)
        end
    end
    
    if isShotgun then
        for i = 1, 8 do
            local spreadOffset = Vector3.new(math.random(-2, 2), math.random(-2, 2), math.random(-2, 2))
            createSingleBeam(sPos, ePos + spreadOffset)
        end
    else
        createSingleBeam(sPos, ePos)
    end
end

local function Create2DHitmarker(worldPosition)
    if not Cfg.hitmarker.enabled or (Cfg.hitmarker.mode ~= "2D" and Cfg.hitmarker.mode ~= "Both") then return end
    local screenPos, onScreen = cam:WorldToViewportPoint(worldPosition)
    if not onScreen then return end
    local center = Vector2.new(screenPos.X, screenPos.Y)
    local directions = {Vector2.new(-1, -1), Vector2.new(1, -1), Vector2.new(-1, 1), Vector2.new(1, 1)}
    local lines = {}
    for _, dir in pairs(directions) do
        if Cfg.hitmarker.outline then
            local outline = Drawing.new("Line")
            outline.Thickness = Cfg.hitmarker.thickness + (Cfg.hitmarker.outline_thickness * 2)
            outline.Color = Cfg.hitmarker.outline_color
            outline.From = center + dir * Cfg.hitmarker.gap
            outline.To = center + dir * (Cfg.hitmarker.gap + Cfg.hitmarker.size)
            outline.Visible = true
            table.insert(lines, outline)
        end
        local line = Drawing.new("Line")
        line.Thickness = Cfg.hitmarker.thickness
        line.Color = Cfg.hitmarker.color
        line.From = center + dir * Cfg.hitmarker.gap
        line.To = center + dir * (Cfg.hitmarker.gap + Cfg.hitmarker.size)
        line.Visible = true
        table.insert(lines, line)
    end
    task.spawn(function()
        local start = tick()
        while tick() - start < Cfg.hitmarker.duration do
            local alpha = 1 - ((tick() - start) / Cfg.hitmarker.duration)
            for _, l in pairs(lines) do l.Transparency = alpha end
            task.wait()
        end
        for _, l in pairs(lines) do l:Remove() end
    end)
end

local function Create3DHitmarker(worldPosition)
    if not Cfg.hitmarker.enabled or (Cfg.hitmarker.mode ~= "3D" and Cfg.hitmarker.mode ~= "Both") then return end
    local hitmarkerData = {lines = {}, position = worldPosition}
    local directions = {Vector3.new(-1, -1, 0), Vector3.new(1, -1, 0), Vector3.new(-1, 1, 0), Vector3.new(1, 1, 0)}
    for _, dir in pairs(directions) do
        if Cfg.hitmarker.outline then
            local outline = Drawing.new("Line")
            outline.Thickness = Cfg.hitmarker.thickness + (Cfg.hitmarker.outline_thickness * 2)
            outline.Color = Cfg.hitmarker.outline_color
            outline.Visible = true
            table.insert(hitmarkerData.lines, {line = outline, dir = dir})
        end
        local line = Drawing.new("Line")
        line.Thickness = Cfg.hitmarker.thickness
        line.Color = Cfg.hitmarker.color
        line.Visible = true
        table.insert(hitmarkerData.lines, {line = line, dir = dir})
    end
    table.insert(State.Active3DHitmarkers, hitmarkerData)
    task.spawn(function()
        local start = tick()
        while tick() - start < Cfg.hitmarker.duration do
            local alpha = 1 - ((tick() - start) / Cfg.hitmarker.duration)
            for _, data in pairs(hitmarkerData.lines) do data.line.Transparency = alpha end
            task.wait()
        end
        for _, data in pairs(hitmarkerData.lines) do data.line:Remove() end
        for i, v in pairs(State.Active3DHitmarkers) do if v == hitmarkerData then table.remove(State.Active3DHitmarkers, i) break end end
    end)
end

local function CreateHitClone(character)
    if not Cfg.hitClone.Enabled or not character then return end
    local cloneModel = Instance.new("Model", workspace.CurrentCamera)
    cloneModel.Name = "HitClone"
    for _, part in ipairs(character:GetChildren()) do
        if part:IsA("BasePart") and isBodyPart(part.Name) then
            local clonePart = part:Clone()
            clonePart.TextureID = ""
            for _, child in ipairs(clonePart:GetChildren()) do if not child:IsA("SpecialMesh") then child:Destroy() end end
            clonePart.Name, clonePart.CFrame, clonePart.Anchored = part.Name, part.CFrame, true
            clonePart.CanCollide, clonePart.CanTouch, clonePart.CanQuery = false, false, false
            clonePart.Material = Enum.Material[Cfg.hitClone.Material] or Enum.Material.Neon
            clonePart.Color, clonePart.CastShadow = Cfg.hitClone.Color, false
            clonePart.Transparency = Cfg.hitClone.Material == "Neon" and 0 or 0.3
            clonePart.Parent = cloneModel
        end
    end
    task.spawn(function()
        task.wait(Cfg.hitClone.Lifetime)
        cloneModel:Destroy()
    end)
end

Services.RunService.RenderStepped:Connect(function()
    for _, data in pairs(State.Active3DHitmarkers) do
        local screenPos, onScreen = cam:WorldToViewportPoint(data.position)
        if onScreen then
            local center = Vector2.new(screenPos.X, screenPos.Y)
            for _, lineData in pairs(data.lines) do
                lineData.line.Visible = true
                lineData.line.From = center + Vector2.new(lineData.dir.X, lineData.dir.Y) * Cfg.hitmarker.gap
                lineData.line.To = center + Vector2.new(lineData.dir.X, lineData.dir.Y) * (Cfg.hitmarker.gap + Cfg.hitmarker.size)
            end
        else
            for _, lineData in pairs(data.lines) do lineData.line.Visible = false end
        end
    end
end)

local function getTarget()
    local closest_player, closest_distance = nil, math.huge
    local mouse_pos = Services.UIS:GetMouseLocation()
    for _, player in ipairs(Services.Players:GetPlayers()) do
        if player ~= lp and player.Character then
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local screen_pos, on_screen = cam:WorldToViewportPoint(hrp.Position)
                if on_screen then
                    local distance = (Vector2.new(screen_pos.X, screen_pos.Y) - mouse_pos).Magnitude
                    if distance < closest_distance then closest_distance = distance; closest_player = player end
                end
            end
        end
    end
    return closest_player
end

local function TriggerEffects(player, hitPosition)
    local now = tick()
    if now - Cfg.monitoring.last_hit_time < Cfg.monitoring.hit_cooldown then return end
    Cfg.monitoring.last_hit_time = now
    
    Create2DHitmarker(hitPosition)
    Create3DHitmarker(hitPosition)
    CreateHitClone(player.Character)
    
    local origin = GetGunOrigin()
    if origin then
        CreateBulletTracer(origin, hitPosition, IsHoldingShotgun())
    end
end

